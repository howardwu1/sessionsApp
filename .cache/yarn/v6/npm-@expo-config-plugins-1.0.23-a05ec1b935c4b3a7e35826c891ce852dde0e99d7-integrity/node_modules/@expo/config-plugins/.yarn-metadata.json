{
  "manifest": {
    "name": "@expo/config-plugins",
    "version": "1.0.23",
    "description": "A library for Expo config plugins",
    "main": "build/index.js",
    "scripts": {
      "watch": "tsc --watch",
      "build": "tsc",
      "prepare": "yarn run clean && yarn build",
      "clean": "rimraf build ./tsconfig.tsbuildinfo",
      "lint": "eslint .",
      "test": "jest"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/expo/expo-cli.git",
      "directory": "packages/config-plugins"
    },
    "keywords": [
      "json",
      "expo",
      "react-native",
      "react"
    ],
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/expo/expo-cli/issues"
    },
    "homepage": "https://github.com/expo/expo-cli/tree/master/packages/config-plugins#readme",
    "files": [
      "build",
      "paths"
    ],
    "dependencies": {
      "@expo/config-types": "^40.0.0-beta.2",
      "@expo/configure-splash-screen": "0.3.4",
      "@expo/image-utils": "0.3.11",
      "@expo/json-file": "8.2.28-alpha.0",
      "@expo/plist": "0.0.11",
      "find-up": "~5.0.0",
      "fs-extra": "9.0.0",
      "getenv": "^1.0.0",
      "glob": "7.1.6",
      "resolve-from": "^5.0.0",
      "slash": "^3.0.0",
      "slugify": "^1.3.4",
      "xcode": "^2.1.0",
      "xml2js": "^0.4.23"
    },
    "devDependencies": {
      "@types/find-up": "^4.0.0",
      "@types/fs-extra": "^9.0.1",
      "@types/xml2js": "^0.4.5",
      "memfs": "^2.15.5",
      "rimraf": "^3.0.2"
    },
    "publishConfig": {
      "access": "public"
    },
    "_registry": "npm",
    "_loc": "/home/howard/.cache/yarn/v6/npm-@expo-config-plugins-1.0.23-a05ec1b935c4b3a7e35826c891ce852dde0e99d7-integrity/node_modules/@expo/config-plugins/package.json",
    "readmeFilename": "README.md",
    "readme": "# Expo Config Plugins\n\nThe Expo config is a powerful tool for generating native app code from a unified JavaScript interface. Most basic functionality can be controlled by using the the [static Expo config](https://docs.expo.io/versions/latest/config/app/), but some features require manipulation of the native project files. To support complex behavior we've created config plugins, and mods (short for modifiers).\n\n> üí° **Hands-on Learners**: Use [this sandbox][sandbox] to play with the core functionality of Expo config plugins. For more complex tests, use a local Expo project, with `expo eject --no-install` to apply changes.\n\n- [Usage](#usage)\n- [What are plugins](#what-are-plugins)\n- [Creating a plugin](#creating-a-plugin)\n  - [Importing plugins](#importing-plugins)\n  - [Chaining plugins](#chaining-plugins)\n- [What are mods](#what-are-mods)\n- [How mods works](#how-mods-works)\n  - [Default mods](#default-mods)\n  - [Mod plugins](#mod-plugins)\n- [Creating a mod](#creating-a-mod)\n  - [Experimental functionality](#experimental-functionality)\n- [Plugin module resolution](#plugin-module-resolution)\n  - [Project file](#project-file)\n  - [app.plugin.js](#apppluginjs)\n  - [Node module default file](#node-module-default-file)\n  - [Project folder](#project-folder)\n  - [Module internals](#module-internals)\n  - [Raw functions](#raw-functions)\n- [Why app.plugin.js for plugins](#why-apppluginjs-for-plugins)\n\n**Quick facts**\n\n- Plugins are functions that can change values on your Expo config.\n- Plugins are mostly meant to be used with [`expo eject`][cli-eject] or `eas build` commands.\n- We recommend you use plugins with `app.config.json` or `app.config.js` instead of `app.json` (no top-level `expo` object is required).\n- `mods` are async functions that modify native project files, such as source code or configuration (plist, xml) files.\n- Changes performed with `mods` will require rebuilding the affected native projects.\n- `mods` are removed from the public app manifest.\n- üí° Everything in the Expo config must be able to be converted to JSON (with the exception of the `mods` field). So no async functions outside of `mods` in your config plugins!\n\n## Usage\n\nHere is a basic config that uses the `expo-splash-screen` plugin:\n\n```json\n{\n  \"name\": \"my app\",\n  \"plugins\": [\"expo-splash-screen\"]\n}\n```\n\nSome plugins can be customized by passing an array, where the second argument is the options:\n\n```json\n{\n  \"name\": \"my app\",\n  \"plugins\": [\n    [\n      \"expo-splash-screen\",\n      {\n        /* Values passed to the plugin */\n      }\n    ]\n  ]\n}\n```\n\nIf you run `expo eject`, the `mods` will be compiled, and the native files be changed! The changes won't be fully shown until you rebuild the native project with `eas build -p ios` or locally with `npx react-native run-ios` or `npx react-native run-android`.\n\nFor instance, if you add a plugin that adds permission messages to your app, the app will need to be rebuilt.\n\nAnd that's it! Now you're using Config plugins. No more having to interact with the native projects!\n\n> üí° Check out all the different ways you can import `plugins`: [plugin module resolution](#Plugin-module-resolution)\n\n## What are plugins\n\nPlugins are **synchronous** functions that accept an [`ExpoConfig`][config-docs] and return a modified [`ExpoConfig`][config-docs].\n\n- Plugins should be named using the following convention: `with<Plugin Functionality>` i.e. `withFacebook`.\n- Plugins should be synchronous and their return value should be serializable, except for any `mods` that are added.\n- Optionally, a second argument can be passed to the plugin to configure it.\n- `plugins` are always invoked when the config is read by `@expo/config`s `getConfig` method. However, the `mods` are only invoked during the \"syncing\" phase of `expo eject`.\n\n## Creating a plugin\n\n> üí° Hands-on learners: Try this [sandbox](https://codesandbox.io/s/expo-config-plugins-basic-example-xopto?file=/src/project/app.config.js) (check the terminal logs).\n\nHere is an example of the most basic config plugin:\n\n```ts\nconst withNothing = config => config;\n```\n\nSay you wanted to create a plugin which added custom values to the native iOS Info.plist:\n\n```ts\nconst withMySDK = (config, { apiKey }) => {\n  // Ensure the objects exist\n  if (!config.ios) {\n    config.ios = {};\n  }\n  if (!config.ios.infoPlist) {\n    config.ios.infoPlist = {};\n  }\n\n  // Append the apiKey\n  config.ios.infoPlist['MY_CUSTOM_NATIVE_IOS_API_KEY'] = apiKey;\n\n  return config;\n};\n\n// üí° Usage:\n\n/// Create a config\nconst config = {\n  name: 'my app',\n};\n\n/// Use the plugin\nexport default withMySDK(config, { apiKey: 'X-XXX-XXX' });\n```\n\n### Importing plugins\n\nYou may want to create a plugin in a different file, here's how:\n\n- The root file can be any JS file or a file named `app.plugin.js` in the [root of a Node module](#root-app.plugin.js).\n- The file should export a function that satisfies the [`ConfigPlugin`][configplugin] type.\n- Plugins should be transpiled for Node environments ahead of time!\n  - They should support the versions of Node that [Expo supports](https://docs.expo.io/get-started/installation/#requirements) (LTS).\n  - No `import/export` keywords, use `module.exports` in the shipped plugin file.\n  - Expo only transpiles the user's initial `app.config` file, anything more would require a bundler which would add too many \"opinions\" for a config file.\n\nConsider the following example that changes the config name:\n\n```\n‚ï≠‚îÄ‚îÄ app.config.js ‚û°Ô∏è Expo Config\n‚ï∞‚îÄ‚îÄ my-plugin.js ‚û°Ô∏è Our custom plugin file\n```\n\n`my-plugin.js`\n\n```js\nmodule.exports = function withCustomName(config, name) {\n  // Modify the config\n  config.name = 'custom-' + name;\n  // Return the results\n  return config;\n};\n```\n\n`app.config.json`\n\n```json\n{\n  \"name\": \"my-app\",\n  \"plugins\": [\"./my-plugin\", \"app\"]\n}\n```\n\n‚Üì ‚Üì ‚Üì\n\n**Evaluated config JSON**\n\n```json\n{\n  \"name\": \"custom-app\",\n  \"plugins\": [\"./my-plugin\", \"app\"]\n}\n```\n\n### Chaining plugins\n\nOnce you add a few plugins, your `app.config.js` code can become difficult to read and manipulate. To combat this, `@expo/config-plugins` provides a `withPlugins` function which can be used to chain plugins together and execute them in order.\n\n```js\n/// Create a config\nconst config = {\n  name: 'my app',\n};\n\n// ‚ùå Hard to read\nwithDelta(withFoo(withBar(config, 'input 1'), 'input 2'), 'input 3');\n\n// ‚úÖ Easy to read\nimport { withPlugins } from '@expo/config-plugins';\n\nwithPlugins(config, [\n  [withBar, 'input 1'],\n  [withFoo, 'input 2'],\n  // When no input is required, you can just pass the method...\n  withDelta,\n]);\n```\n\nTo support JSON configs, we also added the `plugins` array which just uses `withPlugins` under the hood.\nHere is the same config as above, but even simpler:\n\n```js\nexport default {\n  name: 'my app',\n  plugins: [\n    [withBar, 'input 1'],\n    [withFoo, 'input 2'],\n    [withDelta, 'input 3'],\n  ],\n};\n```\n\n## What are mods\n\nAn async function which accepts a config and a data object, then manipulates and returns both as an object.\n\nModifiers (mods for short) are added to the `mods` object of the Expo config. The `mods` object is different to the rest of the Expo config because it doesn't get serialized after the initial reading, this means you can use it to perform actions _during_ code generation. If possible, you should attempt to use basic plugins instead of mods as they're simpler to work with.\n\n- `mods` are omitted from the manifest and **cannot** be accessed via `Updates.manifest`. mods exist for the sole purpose of modifying native files during code generation!\n- `mods` can be used to read and write files safely during the `expo eject` command. This is how Expo CLI modifies the Info.plist, entitlements, xcproj, etc...\n- `mods` are platform specific and should always be added to a platform specific object:\n\n`app.config.js`\n\n```js\nmodule.exports = {\n  name: 'my-app',\n  mods: {\n    ios: {\n      /* iOS mods... */\n    },\n    android: {\n      /* Android mods... */\n    },\n  },\n};\n```\n\n## How mods work\n\n- The config is read using `getConfig` from `@expo/config`\n- All of the core functionality supported by Expo is added via plugins in `withExpoIOSPlugins`. This is stuff like name, version, icons, locales, etc.\n- The config is passed to the compiler `compileModifiersAsync`\n- The compiler adds base mods which are responsible for reading data (like `Info.plist`), executing a named mod (like `mods.ios.infoPlist`), then writing the results to the file system.\n- The compiler iterates over all of the mods and asynchronously evaluates them, providing some base props like the `projectRoot`.\n  - After each mod, error handling asserts if the mod chain was corrupted by an invalid mod.\n\n<!-- TODO: Move to a section about mod compiler -->\n\n> üí° Here is a [colorful chart](https://whimsical.com/UjytoYXT2RN43LywvWExfK) of the mod compiler for visual learners.\n\n### Default mods\n\nThe following default mods are provided by the mod compiler for common file manipulation:\n\n- `mods.ios.appDelegate` -- Modify the `ios/<name>/AppDelegate.m` as a string.\n- `mods.ios.infoPlist` -- Modify the `ios/<name>/Info.plist` as JSON (parsed with [`@expo/plist`](https://www.npmjs.com/package/@expo/plist)).\n- `mods.ios.entitlements` -- Modify the `ios/<name>/<product-name>.entitlements` as JSON (parsed with [`@expo/plist`](https://www.npmjs.com/package/@expo/plist)).\n- `mods.ios.expoPlist` -- Modify the `ios/<name>/Expo.plist` as JSON (Expo updates config for iOS) (parsed with [`@expo/plist`](https://www.npmjs.com/package/@expo/plist)).\n- `mods.ios.xcodeproj` -- Modify the `ios/<name>.xcodeproj` as an `XcodeProject` object (parsed with [`xcode`](https://www.npmjs.com/package/xcode)).\n\n- `mods.android.manifest` -- Modify the `android/app/src/main/AndroidManifest.xml` as JSON (parsed with [`xml2js`](https://www.npmjs.com/package/xml2js)).\n- `mods.android.strings` -- Modify the `android/app/src/main/res/values/strings.xml` as JSON (parsed with [`xml2js`](https://www.npmjs.com/package/xml2js)).\n- `mods.android.mainActivity` -- Modify the `android/app/src/main/<package>/MainActivity.java` as a string.\n- `mods.android.appBuildGradle` -- Modify the `android/app/build.gradle` as a string.\n- `mods.android.projectBuildGradle` -- Modify the `android/build.gradle` as a string.\n- `mods.android.settingsGradle` -- Modify the `android/settings.gradle` as a string.\n- `mods.android.gradleProperties` -- Modify the `android/gradle.properties` as a `Properties.PropertiesItem[]`.\n\nAfter the mods are resolved, the contents of each mod will be written to disk. Custom default mods can be added to support new native files.\nFor example, you can create a mod to support the `GoogleServices-Info.plist`, and pass it to other mods.\n\n### Mod plugins\n\nMods are responsible for a lot of things, so they can be pretty difficult to understand at first.\nIf you're developing a feature that requires mods, it's best not to interact with them directly.\n\nInstead you should use the helper mods provided by `@expo/config-plugins`:\n\n- iOS\n  - `withAppDelegate`\n  - `withInfoPlist`\n  - `withEntitlementsPlist`\n  - `withExpoPlist`\n  - `withXcodeProject`\n- Android\n  - `withAndroidManifest`\n  - `withStringsXml`\n  - `withMainActivity`\n  - `withProjectBuildGradle`\n  - `withAppBuildGradle`\n  - `withSettingsGradle`\n  - `withGradleProperties`\n\nA mod plugin gets passed a `config` object with additional properties `modResults` and `modRequest` added to it.\n\n- `modResults`: The object to modify and return. The type depends on the mod that's being used.\n- `modRequest`: Additional properties supplied by the mod compiler.\n  - `projectRoot: string`: Project root directory for the universal app.\n  - `platformProjectRoot: string`: Project root for the specific platform.\n  - `modName: string`: Name of the mod.\n  - `platform: ModPlatform`: Name of the platform used in the mods config.\n  - `projectName?: string`: iOS only: The path component used for querying project files. ex. `projectRoot/ios/[projectName]/`\n\n## Creating a mod\n\nSay you wanted to write a mod to update the Xcode Project's \"product name\":\n\n```ts\nimport { ConfigPlugin, withXcodeProject } from '@expo/config-plugins';\n\nconst withCustomProductName: ConfigPlugin = (config, customName) => {\n  return withXcodeProject(config, async config => {\n    // config = { modResults, modRequest, ...expoConfig }\n\n    const xcodeProject = config.modResults;\n    xcodeProject.productName = customName;\n\n    return config;\n  });\n};\n\n// üí° Usage:\n\n/// Create a config\nconst config = {\n  name: 'my app',\n};\n\n/// Use the plugin\nexport default withCustomProductName(config, 'new_name');\n```\n\n### Experimental functionality\n\nSome parts of the mod system aren't fully flushed out, these parts use `withDangerousModifier` to read/write data without a base mod. These methods essentially act as their own base mod and cannot be extended. Icons for example, currently use the dangerous mod to perform a single generation step with no ability to customize the results.\n\n```ts\nexport const withIcons: ConfigPlugin = config => {\n  return withDangerousModifier(config, async config => {\n    // No modifications are made to the config\n    await setIconsAsync(config, config.modRequest.projectRoot);\n    return config;\n  });\n};\n```\n\nBe careful using `withDangerousModifier` as it is subject to change in the future.\nThe order with which it gets executed is not reliable either.\nCurrently dangerous mods run first before all other modifiers, this is because we use dangerous mods internally for large file system refactoring like when the package name changes.\n\n## Plugin module resolution\n\nThe strings passed to the `plugins` array can be resolved in a few different ways.\n\n> Any resolution pattern that isn't specified below is unexpected behavior, and subject to breaking changes.\n\n### Project file\n\nYou can quickly create a plugin in your project and use it in your config.\n\n- ‚úÖ `'./my-config-plugin'`\n- ‚ùå `'./my-config-plugin.js'`\n\n```\n‚ï≠‚îÄ‚îÄ app.config.js ‚û°Ô∏è Expo Config\n‚ï∞‚îÄ‚îÄ my-config-plugin.js ‚û°Ô∏è ‚úÖ `module.exports = (config) => config`\n```\n\n### app.plugin.js\n\nSometimes you want your package to export React components and also support a plugin, to do this, multiple entry points need to be used (because the transpilation (Babel preset) may be different).\nIf a `app.plugin.js` file is present in the root of a Node module's folder, it'll be used instead of the package's `main` file.\n\n- ‚úÖ `'expo-splash-screen'`\n- ‚ùå `'expo-splash-screen/app.plugin.js'`\n\n```\n‚ï≠‚îÄ‚îÄ app.config.js ‚û°Ô∏è Expo Config\n‚ï∞‚îÄ‚îÄ node_modules/expo-splash-screen/ ‚û°Ô∏è Module installed from NPM (works with Yarn workspaces as well).\n    ‚îú‚îÄ‚îÄ package.json ‚û°Ô∏è The `main` file will be used if `app.plugin.js` doesn't exist.\n    ‚îú‚îÄ‚îÄ app.plugin.js ‚û°Ô∏è ‚úÖ `module.exports = (config) => config` -- must export a function.\n    ‚ï∞‚îÄ‚îÄ build/index.js ‚û°Ô∏è ‚ùå Ignored because `app.plugin.js` exists. This could be used with `expo-splash-screen/build/index.js`\n```\n\n### Node module default file\n\nA config plugin in a node module (without an `app.plugin.js`) will use the `main` file defined in the `package.json`.\n\n- ‚úÖ `'expo-splash-screen'`\n- ‚ùå `'expo-splash-screen/build/index'`\n\n```\n‚ï≠‚îÄ‚îÄ app.config.js ‚û°Ô∏è Expo Config\n‚ï∞‚îÄ‚îÄ node_modules/expo-splash-screen/ ‚û°Ô∏è Module installed from NPM (works with Yarn workspaces as well).\n    ‚îú‚îÄ‚îÄ package.json ‚û°Ô∏è The `main` file points to `build/index.js`\n    ‚ï∞‚îÄ‚îÄ build/index.js ‚û°Ô∏è  ‚úÖ Node resolves to this module.\n```\n\n### Project folder\n\n- ‚úÖ `'./my-config-plugin'`\n- ‚ùå `'./my-config-plugin.js'`\n\nThis is different to how Node modules work because `app.plugin.js` won't be resolved by default in a directory. You'll have to manually specify `./my-config-plugin/app.plugin.js` to use it, otherwise `index.js` in the directory will be used.\n\n```\n‚ï≠‚îÄ‚îÄ app.config.js ‚û°Ô∏è Expo Config\n‚ï∞‚îÄ‚îÄ my-config-plugin/ ‚û°Ô∏è Folder containing plugin code\n    ‚ï∞‚îÄ‚îÄ index.js ‚û°Ô∏è ‚úÖ By default, Node resolves a folder's index.js file as the main file.\n```\n\n### Module internals\n\nIf a file inside a Node module is specified, then the module's root `app.plugin.js` resolution will be skipped. This is referred to as \"reaching inside a package\" and is considered **bad form**.\nWe support this to make testing, and plugin authoring easier, but we don't expect library authors to expose their plugins like this as a public API.\n\n- ‚ùå `'expo-splash-screen/build/index.js'`\n- ‚ùå `'expo-splash-screen/build'`\n\n```\n‚ï≠‚îÄ‚îÄ app.config.js ‚û°Ô∏è Expo Config\n‚ï∞‚îÄ‚îÄ node_modules/expo-splash-screen/ ‚û°Ô∏è Module installed from npm (works with Yarn workspaces as well).\n    ‚îú‚îÄ‚îÄ package.json ‚û°Ô∏è The `main` file will be used if `app.plugin.js` doesn't exist.\n    ‚îú‚îÄ‚îÄ app.plugin.js ‚û°Ô∏è ‚ùå Ignored because the reference reaches into the package internals.\n    ‚ï∞‚îÄ‚îÄ build/index.js ‚û°Ô∏è ‚úÖ `module.exports = (config) => config`\n```\n\n### Raw functions\n\nYou can also just pass in a config plugin.\n\n```js\nconst withCustom = (config, props) => config;\n\nconst config = {\n  plugins: [\n    [\n      withCustom,\n      {\n        /* props */\n      },\n    ],\n    // Without props\n    withCustom,\n  ],\n};\n```\n\nOne caveat to using functions instead of strings is that serialization will replace the function with the function's name. This keeps **manifests** (kinda like the `index.html` for your app) working as expected.\n\nHere is what the serialized config would look like:\n\n```json\n{\n  \"plugins\": [[\"withCustom\", {}], \"withCustom\"]\n}\n```\n\n## Why app.plugin.js for plugins\n\nConfig resolution searches for a `app.plugin.js` first when a Node module name is provided.\nThis is because Node environments are often different to iOS, Android, or web JS environments and therefore require different transpilation presets (ex: `module.exports` instead of `import/export`).\n\nBecause of this reasoning, the root of a Node module is searched instead of right next to the `index.js`. Imagine you had a TypeScript Node module where the transpiled main file was located at `build/index.js`, if Expo config plugin resolution searched for `build/app.plugin.js` you'd lose the ability to transpile the file differently.\n\n[config-docs]: https://docs.expo.io/versions/latest/config/app/\n[cli-eject]: https://docs.expo.io/workflow/expo-cli/#eject\n[sandbox]: https://codesandbox.io/s/expo-config-plugins-8qhof?file=/src/project/app.config.js\n[configplugin]: ./src/Plugin.types.ts\n\n## Debugging\n\nYou can debug config plugins by running `expo prebuild`. If `EXPO_DEBUG` is enabled, the plugin stack logs will be printed, these are useful for viewing which mods ran, and in what order they ran in. To view all static plugin resolution errors, enable `EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS`, this should only be needed for plugin authors.\nBy default some automatic plugin errors are hidden because they're usually related to versioning issues and aren't very helpful (i.e. legacy package doesn't have a config plugin yet).\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2015-present 650 Industries, Inc. (aka Expo)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@expo/config-plugins/-/config-plugins-1.0.23.tgz#a05ec1b935c4b3a7e35826c891ce852dde0e99d7",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@expo/config-plugins/-/config-plugins-1.0.23.tgz",
    "hash": "a05ec1b935c4b3a7e35826c891ce852dde0e99d7",
    "integrity": "sha512-LjglO6CHC69qYjOynRsDBKuVbL2W3UPJs6nghgJR5aNhQCZtQsc74p4NWbQEkbPEasNtGCb355PlsV2fQskFaQ==",
    "registry": "npm",
    "packageName": "@expo/config-plugins",
    "cacheIntegrity": "sha512-LjglO6CHC69qYjOynRsDBKuVbL2W3UPJs6nghgJR5aNhQCZtQsc74p4NWbQEkbPEasNtGCb355PlsV2fQskFaQ== sha1-oF7BuTXEs6fjWCbIkc6FLd4Omdc="
  },
  "registry": "npm",
  "hash": "a05ec1b935c4b3a7e35826c891ce852dde0e99d7"
}