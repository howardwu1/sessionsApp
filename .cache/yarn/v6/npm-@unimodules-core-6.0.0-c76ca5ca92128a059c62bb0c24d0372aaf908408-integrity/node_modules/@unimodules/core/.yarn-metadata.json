{
  "manifest": {
    "name": "@unimodules/core",
    "version": "6.0.0",
    "description": "Universal modules core",
    "main": "build/index.js",
    "types": "build/index.d.ts",
    "sideEffects": false,
    "scripts": {
      "build": "expo-module build",
      "clean": "expo-module clean",
      "lint": "expo-module lint",
      "test": "expo-module test",
      "prepare": "expo-module prepare",
      "prepublishOnly": "expo-module prepublishOnly",
      "expo-module": "expo-module"
    },
    "keywords": [
      "unimodules"
    ],
    "repository": {
      "type": "git",
      "url": "https://github.com/expo/expo.git",
      "directory": "packages/@unimodules/core"
    },
    "bugs": {
      "url": "https://github.com/expo/expo/issues"
    },
    "author": {
      "name": "650 Industries, Inc."
    },
    "license": "MIT",
    "homepage": "https://github.com/expo/expo/tree/master/packages/@unimodules/core",
    "jest": {
      "preset": "expo-module-scripts/ios"
    },
    "dependencies": {
      "compare-versions": "^3.4.0"
    },
    "devDependencies": {
      "expo-module-scripts": "~1.2.0"
    },
    "gitHead": "bc6b4b3bc3cb5e44e477f145c72c07ed09588651",
    "_registry": "npm",
    "_loc": "/home/howard/.cache/yarn/v6/npm-@unimodules-core-6.0.0-c76ca5ca92128a059c62bb0c24d0372aaf908408-integrity/node_modules/@unimodules/core/package.json",
    "readmeFilename": "README.md",
    "readme": "# @unimodules/core\n\n## JavaScript installation\n\n```sh\n$ yarn add @unimodules/core\n\n# or\n\n$ npm install @unimodules/core --save\n```\n\n## Installation\n\nIf you are using `react-native-unimodules`, this package will already be installed and configured!\n\n### iOS (Cocoapods)\n\nIf you're using Cocoapods, add the following dependency to your `Podfile`:\n\n`pod 'UMCore', path: '../node_modules/@unimodules/core/ios'`\n\nand run `npx pod-install`.\n\n### Android\n\n1.  Append the following lines to `android/settings.gradle`:\n    ```gradle\n    include ':unimodules-core'\n    project(':unimodules-core').projectDir = new File(rootProject.projectDir, '../node_modules/@unimodules/core/android')\n    ```\n2.  Insert the following lines inside the dependencies block in `android/app/build.gradle`:\n    ```gradle\n    compile project(':unimodules-core')\n    ```\n3.  If you're using ProGuard, you'll need to append these lines to your ProGuard rules file for it not to strip out methods required for Expo modules to work.\n    ```pro\n    -keepclassmembers class * {\n      @org.unimodules.interfaces.ExpoProp *;\n    }\n    -keepclassmembers class * {\n      @org.unimodules.interfaces.ExpoMethod *;\n    }\n    ```\n\n## Usage\n\n### Glossary\n\n- **Native code** — iOS/Android native code.\n- **Client code** — code _over the bridge_, for React Native it's the JavaScript app.\n- **Internal module** — a class implementing `UMInternalModule`/`org.unimodules.interfaces.InternalModule` interface. Its instance can be exposed internally to other modules via *Module Registry* (how dependants reference modules differs between platforms).\n- **Module interface** — an interface that should be implemented by the dependency so it can act as an implementation of it.\n\n    On Android modules implement an external interface (`expo-file-system` package implements interface provided by `expo-file-system-interface`). Dependants may access the implementations by calling\n    ```java\n    public <T> T getModule(Class<T> interfaceClass);\n    ```\n    method on the module registry.\n\n    On iOS its the consumer who defines required protocol. Implementations are identified by a protocol. Dependants access the implementation by calling\n    ```objc\n    - (id)getModuleImplementingProtocol:(Protocol *)protocol;\n    ```\n    method on the module registry.\n- **Module Registry** — well, a registry of modules. Instance of this class is used to fetch another internal or exported module.\n- **Exported methods** — a subset of instance methods of a given module that should get exposed to client code by specific platform adapter.\n- **Exported module** — a subclass of `{UM,org.unimodules.}ExportedModule`. Its methods annotated with `org.unimodules.ExpoMethod`/`UM_EXPORT_METHOD_AS` are exported to client code.\n- **View manager** — a class capable of providing platform adapter with custom views.\n\n### Registering modules in the registry\n\n#### iOS\n\n1. Open the header file for your module.\n2. Import `<UMCore/UMInternalModule.h>`.\n3. Add `UMModule` to a list of implemented interfaces by the module instances (eg. `NSObject <UMInternalModule>`). \n4. Open the implementation file for your module and implement methods required by the protocol.\n5. Use `UM_REGISTER_MODULE();` macro to register the module.\n6. That's it!\n\n#### Android\n\n1. Add `org.unimodules.interfaces.InternalModule` to your class's imports.\n2. Make your module class implement `InternalModule` interface.\n    1. Implement `public List<Class> getExportedInterfaces();`. Return a list of module interfaces implemented by the class, for example:\n        ```java\n        return Collections.singletonList((Class) org.unimodules.interfaces.filesystem.FileSystem.class);\n        ```\n3. Create a `Package` class for your module, unless you already have one.\n    1. A `Package` class should implement `org.unimodules.Package` interface (a `BasePackage` class is provided for you not to have to implement all the initialization flavors at once).\n    2. Add the `Package` to a `List` provided to `ModuleRegistryBuilder`.\n        ```java\n        new ModuleRegistryBuilder(\n          Arrays.<Package>asList(\n            new FileSystemPackage()\n          )\n        )\n        ```\n4. Add your module to be returned by `List<InternalModule> createInternalModules(Context context);`.\n5. You're good to go!\n\n### Exporting module to client code\n\n#### iOS\n\nWhen registering your module for export to client code, you must first decide whether the class will only be exported to client code or will it be both internal and exported module. If the former is applicable, you easily just subclass `UMExportedModule` and use macro `UM_EXPORT_MODULE(clientCodeName)` to provide a name under which it should be exported. If your module should be both internal and exported module, you also have to subclass `UMExportedModule`, but this time use `UM_REGISTER_MODULE()` in the implementation and then manually override methods `exportedInterfaces` and `exportedModuleName`.\n\n#### Android\n\nSubclass `org.unimodules.ExportedModule` and add your module to a list returned by `Package` in `createExportedModules()`.\n\n### Exporting methods and calling exported methods\n\n#### iOS\n\nUse `UM_EXPORT_METHOD_AS(exportedName, definition)` macro to export given method to client code. Note that for the module to be available in the client code you have to provide a non-empty client code name in `UM_EXPORT_MODULE(clientCodeName)` or `- (const NSString *)exportedModuleName`. For now, arguments have to use basic, object types, like `NSString *`, `NSDictionary *`, `NSNumber *`. Methods are required to receive `UMPromiseResolveBlock` and `UMPromiseRejectBlock` as two last arguments.\n\n#### Android\n\nGiven that your module subclasses `org.unimodules.ExportedModule` and it is returned by the respective `Package`, you just have to annotate the given method with `@ExpoMethod` annotation. Methods are required to receive `org.unimodules.Promise` as the last argument.\n\n### Exporting constants to client code\n\n#### iOS\n\nImplement `- (NSDictionary *)constantsToExport` method to export constants to client code.\n\n#### Android\n\nOverride `public Map<String, Object> getConstants();` method to export constants to client code.\n\n### Creating a custom view manager\n\n#### iOS\n\nSubclass `UMViewManager` and override at least `- (UIView *)view` and `- (NSString *)viewName`. Register it with `UM_REGISTER_MODULE()`.\n\nUse `UM_VIEW_PROPERTY(propName, propClass, viewClass)` to define custom view properties.\n\n#### Android\n\nTODO: ViewManager from interface to a class\n\nImplement `org.unimodules.interfaces.ViewManager` in your class and respond with its instance in `List<ViewManager> createViewManagers(Context context);` in corresponding `Package`.\n\nAnnotate prop setter methods with `@ExpoProp(name = <name>)` to define custom view properties.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@unimodules/core/-/core-6.0.0.tgz#c76ca5ca92128a059c62bb0c24d0372aaf908408",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@unimodules/core/-/core-6.0.0.tgz",
    "hash": "c76ca5ca92128a059c62bb0c24d0372aaf908408",
    "integrity": "sha512-+KCVh+NjU33lkHOFiRfJZR6dDsSF8zCY1CVARMYJbQ7w1epRsalpKnCK08JoNYHQqkPR79d2zQSWMxd20zBvoA==",
    "registry": "npm",
    "packageName": "@unimodules/core",
    "cacheIntegrity": "sha512-+KCVh+NjU33lkHOFiRfJZR6dDsSF8zCY1CVARMYJbQ7w1epRsalpKnCK08JoNYHQqkPR79d2zQSWMxd20zBvoA== sha1-x2ylypISigWcYrsMJNA3Kq+QhAg="
  },
  "registry": "npm",
  "hash": "c76ca5ca92128a059c62bb0c24d0372aaf908408"
}